from datetime import timedelta
from django.utils import timezone
from pydantic_core import ValidationError 
from .models import *


# How a class and methods would be used in view_utils. Follows normal python
class ExampleCalculations:
    def __init__(self, example: int = 0):
        self.example_num = example

    def run_example_calculation(self, num):

        # This is how you would create a new object in the database for a model
        # Automatically increments the PK, can leave fields out that aren't essential
        example_object = ExampleModel.objects.create(field1="abc", field2=1, field3=0.1)

        # Have to save
        example_object.save()

        # Fields are stored as attributes of objects. For example, to alter an object, you can just use the . operator
        example_object.field1 = "def"
        example_object.save()

        number = example_object.field2 + self.example_num + num
        return number


class TransactionViews:

    LISTING_UNAVAILABLE = "unavailable"

    def __init__(self, pk: int):
        self.transaction = Transaction.objects.get(pk=pk)

    def create_transaction(
        self,
        listing: Listing,
        borrower: User,
        start_date=None,
        end_date=None,
        status: str = Status.IN_PROGRESS,
    ) -> Transaction:
        """
        Creates a new transaction, locks the listing,
        and creates a chat between the lender and borrower 
        for the transaction.
        """
        if start_date is None:
            start_date = timezone.now()
        if end_date is None:
            end_date = start_date + timedelta(days=1)

        if start_date >= end_date:
            raise ValidationError("start_date must be before end_date.")

        with Transaction.atomic():
            locked_listing = Listing.objects.select_for_update().get(pk=listing.pk)

            if locked_listing.status != Status.OPEN:
                raise ValidationError("Listing is not available.")

            if borrower.pk == locked_listing.user_id:
                raise ValidationError("Cannot complete a transaction with yourself.")

            # Keeps transactions according to availability
            if start_date < locked_listing.start_date or end_date > locked_listing.end_date:
                raise ValidationError("Transaction dates must be within the listing start or end dates.")

            # Locks the selected listing
            locked_listing.status = self.LISTING_UNAVAILABLE
            locked_listing.save()

            new_tx = Transaction.objects.create(
                listing=locked_listing,
                lender=locked_listing.user,
                borrower=borrower,
                start_date=start_date,
                end_date=end_date,
                status=status,
            )

            Chat.objects.create(transaction=new_tx)
            return new_tx

    def update_transaction(
        self,
        start_date=None,
        end_date=None,
        status: str = None,
        borrower: User = None,
    ) -> Transaction:
        if start_date is not None:
            self.transaction.start_date = start_date
        if end_date is not None:
            self.transaction.end_date = end_date

        if (start_date is not None) or (end_date is not None):
            if self.transaction.start_date >= self.transaction.end_date:
                raise ValidationError("start_date must be before end_date.")

        if status is not None:
            self.transaction.status = status
        if borrower is not None:
            self.transaction.borrower = borrower

        self.transaction.save()
        return self.transaction

    def complete_transaction(self, acting_user: User) -> Transaction:
        """
        Mark transaction completed & unlock listing.
        """
        with Transaction.atomic():
            tx = Transaction.objects.select_for_update().get(pk=self.transaction.pk)

            if tx.status == Status.COMPLETED:
                self.transaction = tx
                return tx

            if acting_user.pk not in (tx.lender_id, tx.borrower_id):
                raise ValidationError("Not authorized to complete this transaction.")

            listing = Listing.objects.select_for_update().get(pk=tx.listing_id)

            tx.status = Status.COMPLETED
            tx.save()


<<<<<<< HEAD
||||||| b474b9c
class UserViews:
    def __init__(self):
        self.user = None

    def create_user(self, f_name, l_name, photo_url, user_bio):
        self.user = User.objects.create()

    def get_user(self, pk):
        self.user = User.objects.get(pk=pk)

    def update_user(self, **kwargs):
        ALLOWED_FIELDS = [
            "f_name",
            "l_name",
            "address",
            "photo_url",
            "user_bio",
            "role",
            "neighborhood",
        ]

        for field, value in kwargs:
            if field is not None and field in ALLOWED_FIELDS:
                if field == "role" and (value != "admin" or value != "neighbor"):
                    return {"error", "invalid role keyword"}
                setattr(self.user, field, value)
        self.user.save()
        return self.user

    def delete_user(self, user_id):
        User.objects.delete(user_id)


=======
class UserViews:
    def __init__(self):
        self.user = None

    def create_user(self, f_name, l_name, photo_url, user_bio):
        self.user = User.objects.create()

    def get_user(self, pk):
        self.user = User.objects.get(pk=pk)

    def update_user(self, **kwargs):
        ALLOWED_FIELDS = [
            "f_name",
            "l_name",
            "address",
            "photo_url",
            "user_bio",
            "role",
            "neighborhood",
        ]

        for field, value in kwargs:
            if field is not None and field in ALLOWED_FIELDS:
                if field == "role" and (value != "admin" or value != "neighbor"):
                    return {"error", "invalid role keyword"}
                setattr(self.user, field, value)
        self.user.save()
        return self.user

    def set_profile(self, photo_url, user_bio):
        self.user.photo_url = photo_url
        self.user.user_bio = user_bio

        self.user.save()

    def set_admin(self):
        self.user.role = "admin"

        self.user.save()

    def set_neighbor(self):
        self.user.role = "neighbor"

        self.user.save()

    def set_neighborhood(self, neighborhood):
        self.user.neighborhood = neighborhood

        self.user.save()


>>>>>>> main
class TrustFeedbackViews:
    def __init__(self, pk: int):
        self.tfv = TrustFeedback.objects.get(pk=pk)
        self.transaction: Transaction = self.tfv.transaction
        self.lender: User = self.tfv.lender
        self.borrower: User = self.tfv.borrower

    def calc_trust_fields(self, user: User):
        trust_objs_borrowing = TrustFeedback.objects.filter(borrower_id=user.pk)
        trust_objs_lending = TrustFeedback.objects.filter(lender_id=user.pk)
        user.trust_rating = round(
            sum([t.rating_score for t in trust_objs_borrowing])
            / trust_objs_borrowing.count(),
            1,
        )
        user.trust_total_transactions = (
            trust_objs_borrowing.count() + trust_objs_lending.count()
        )
        user.trust_returns_missing = trust_objs_borrowing.filter(
            item_returned=False
        ).count()
        user.trust_damaged_count = trust_objs_borrowing.filter(
            item_condition="damaged"
        ).count()
        user.trust_late_count = trust_objs_borrowing.filter(
            return_timeliness="late"
        ).count()
        user.trust_last_updated = timezone.now()

        user.save()

class ListingViews:
<<<<<<< HEAD
    def __init__(self, pk: int):
        self.listing = Listing.objects.get(pk=pk)

    def create_listing(
        self,
        owner: User,
        title: str,
        listing_bio: str,
        photo_url: str,
        listing_type: str = Listing.Type.REQUEST,
        item: Item = None,
        skill: Skill = None,
        status: str = Status.OPEN,
    ):
        new_listing = Listing.objects.create(
            user=owner,
            title=title,
            listing_bio=listing_bio,
            image_url=photo_url,
            type=listing_type,
            item=item,
            skill=skill,
            start_date=timezone.now(),
            end_date=timezone.now()
            + timedelta(days=7),  # end dates are defaulted to 7 days out
            status=status,
            neighborhood=owner.neighborhood,
        )
        new_listing.save()
        return new_listing

    def update_listing(
        self,
        title: str = None,
        listing_bio: str = None,
        photo_url: str = None,
        listing_type: str = None,
        status: str = None,
        item: Item = None,
        skill: Skill = None,
    ):
        if title:
            self.listing.title = title
        if listing_bio:
            self.listing.listing_bio = listing_bio
        if photo_url:
            self.listing.image_url = photo_url
        if listing_type:
            self.listing.type = listing_type
        if status:
            self.listing.status = status
        if item is not None:
            self.listing.item = item
        if skill is not None:
            self.listing.skill = skill

        self.listing.save()
        return self.listing

    def delete_listing(self):
        self.listing.delete()
        return True
||||||| b474b9c
    pass
=======
    def __init__(self,pk: int):
       self.listing = Listing.objects.get(pk=pk)
>>>>>>> main


    def create_listing (self, owner: User, title: str, listing_bio: str,  photo_url: str, listing_type: str =Listing.Type.REQUEST, 
                        item: Item = None, skill: Skill = None, status: str = Status.OPEN):
        new_listing = Listing.objects.create(
            user = owner,
            title=title,
            listing_bio=listing_bio,
            image_url = photo_url,
            type = listing_type,
            item = item, 
            skill = skill,
            start_date = timezone.now(),
            end_date = timezone.now() + timedelta(days = 7), #end dates are defaulted to 7 days out 
            status = status, 
            neighborhood = owner.neighborhood
)
        new_listing.save()
        return new_listing
    
    def update_listing(self, title: str = None, listing_bio: str = None, photo_url: str = None, listing_type: str = None, status: str = None,
                       item: Item = None, skill: Skill = None):
        if title:
            self.listing.title = title
        if listing_bio:
            self.listing.listing_bio = listing_bio
        if photo_url:
            self.listing.image_url = photo_url      
        if listing_type:    
            self.listing.type = listing_type
        if status:
            self.listing.status = status
        if item is not None:
            self.listing.item = item
        if skill is not None:
            self.listing.skill = skill
        
        
        self.listing.save()
        return self.listing
    
    def delete_listing(self):
        self.listing.delete()
        return True
    

class NeighborhoodViews:
    pass


class ChatViews:
    pass


class MessageViews:
    pass


class ItemViews:
    pass


class SkillViews:
    pass
